---
title: "30 días de gráficos con R"
author: "Maggie"
date: "12/5/2020"
output: html_document
---

# _30 días de gráficos con R_

Desafío de la comunidad hispanoablante de R: [#30díasdegráficos](https://github.com/cienciadedatos/datos-de-miercoles/blob/master/30-dias-de-graficos-2020.md), una iniciativa para compartir y aprender sobre visualización de datos usando R.

El 12 de mayo se conmemora el nacimiento de Florence Nightingale, la enfermera creadora del diagrama de área polar y referente femenina de la visualización de datos.


## _Desafío Día 1: Gráfico de barras o columnas_

Para este desafío utilicé la base de datos de la WNBA proporcionada para la carrera de Analista de Datos en R de [Dataquest](https://www.dataquest.io/path/data-analyst-r/). Para más información sobre la WNBA [visitar](https://www.wnba.com/stats/player-stats/).

Realicé un gráfico de barras que compara las frecuencias de las jugadoras en las distintas posiciones. 

```{r gráfico de barras o columnas}
# Cargar los paquetes requeridos
library(tidyverse)
```

```{r}
# Importar la base de datos
wnba <- read.csv("C:/Users/Maggie/OneDrive/aR/datos_de_miercoles/data/wnba.csv")

# Renombrando los niveles y etiquetas de las variables
wnba$Pos <- factor(wnba$Pos,levels = c("G", "F", "C", "G/F", "F/C"),
                   labels = c("Guard", "Forward", "Center", "Guard/Forward", "Forward/Center")) 

ggplot(data = wnba,
       aes(x = Pos, fill = Pos)) +
  geom_bar() + 
  coord_flip() + 
  theme_classic() +
  theme(legend.position = "none") +
  labs(x=NULL, y=NULL, fill=NULL,
         title="Posiciones de las jugadoras") 
  
pos_prop <- wnba %>% 
  group_by(Pos) %>% 
  summarize(Prop = n() / nrow(wnba))

ggplot(data = pos_prop, 
              aes(x = "", y = Prop, fill = Pos)) + 
  geom_bar(stat = "identity", width = 0.25) +
  coord_flip() +
  theme_classic() +
  geom_text(aes(label = str_c(round(Prop * 100), "%")), 
            position = position_stack(vjust = 0.5)) + 
  theme(axis.line = element_blank(),
          axis.text = element_blank(),
          axis.ticks = element_blank()) +
  labs(x = NULL, 
       y = NULL, 
       fill = NULL, 
       title = "Distribución de jugadoras según su posición") 
   
```
## _Desafío Día 2: Gráfico de líneas_

Para este desafío utilicé datos de [Gapminder](https://www.gapminder.org/data/), por medio del paquete creado por Jennifer Bryan.

Para cada uno de los 142 países, El paquete proporciona información sobre la expectativa de vida, el PIB per cápita y la población, generados cada cinco años, de 1952 a 2007.


Realicé el gráfico de líneas sobre la evolución de la expectativa de vida de los Estados Partes del Mercosur.

```{r gráfico de líneas}
# Importar la base de datos Gapminder
library(gapminder)
```

```{r}
mercosur <- gapminder %>% 
  filter(country == "Argentina" | country == "Brazil" | country == "Paraguay" | country == "Uruguay") 

mercosur$country <- factor(mercosur$country,levels = c("Argentina", "Brazil", "Paraguay", "Uruguay"),
                   labels = c("Argentina", "Brasil", "Paraguay", "Uruguay")) 
  
ggplot(data = mercosur, aes(x = year, y = lifeExp, color = country)) +
  geom_line() + 
  geom_point() +
  theme_minimal() +
  labs(x = NULL, 
       y = NULL, 
       fill = NULL, 
       title = "Evolución de la expectativa de vida en los Estados Partes del Mercosur") 
```

## _Desafío Día 3: Gráfico de puntos o burbujas_

Para este desafío utilicé nuevamente la base de datos de [Gapminder](https://www.gapminder.org/data/), por medio del paquete creado por Jennifer Bryan.

El gráfico de burbujas representa la relación entre la expectativa de vida y el GDP por cápita, de acuerdo al continente y población.

```{r gráfico de burbujas}

# Importar la base de datos Gapminder
# library(gapminder)
```

```{r}
data <- gapminder %>% 
  filter(year=="2007") %>% 
  select(-year) %>% 
  arrange(desc(pop)) %>%
  mutate(country = factor(country, country), 
         Continente = continent) 
  
 data$Continente <- factor(data$Continente,levels = c("Africa", "Americas", "Asia", "Europe", "Oceania"),
                    labels = c("África", "Américas", "Asia ", "Europa", "Oceanía"))

ggplot(data, aes(x = gdpPercap, y = lifeExp, size = pop, color = Continente)) +
  geom_point(alpha = 0.5) +
  scale_size(range = c(.1, 24), name = "Población (M)") +
  labs(x = "Gdp per Capita", 
       y = "Expectativa de vida", 
       title = "Expectativa de vida y GDP per capita según continente y población") +
  theme_bw()
```

## _Desafío Día 4: Gráfico con facetas_

Para este desafío utilicé nuevamente la base de datos de [Gapminder](https://www.gapminder.org/data/), por medio del paquete creado por Jennifer Bryan.

El gráfico de facetas representa sobre la evolución de la expectativa de vida de los Estados Partes del Mercosur.

```{r gráfico con facetas}
# Importar la base de datos Gapminder
# library(gapminder)
```

```{r}
mercosur <- gapminder %>% 
  filter(country == "Argentina" | country == "Brazil" | country == "Paraguay" | country == "Uruguay") 

mercosur$country <- factor(mercosur$country,levels = c("Argentina", "Brazil", "Paraguay", "Uruguay"),
                   labels = c("Argentina", "Brasil", "Paraguay", "Uruguay")) 

ggplot(mercosur, aes(x = year, y = lifeExp, color = country)) +
  geom_line(size = 1.5) +
  labs(x = NULL,
       y = "Expectativa de vida",
       title = "Evolución de la expectativa de vida en los Estados Partes del Mercosur") +
  theme_light() +
  theme(legend.title = element_blank()) +
  facet_wrap(~ country)

```
## _Desafío Día 5: Diagramas de arco_

Esta es la primera vez que hago un diagrama de arco. Decidí realizarlo con los datos de las comunidades de R a las que pertenezco. 

Utilicé el paquete creado por [Gaston Sanchez](https://github.com/gastonstat/arcdiagram) y me basé en sus [especificaciones](http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.707.6275&rep=rep1&type=pdf)

```{r diagrama de arco}
library(tidyverse)
```

```{r}
# load devtools
library(devtools)

# install "arcdiagram"
install_github("gastonstat/arcdiagram")

library(arcdiagram)
library(igraph)
```

```{r}
lab = rbind(c("Maggie", "R-Ladies \n Montevideo"), c("Maggie", "GURU::mvd"), c("Maggie", "R-Ladies \n Buenos Aires"),c("Maggie", "R en \n Buenos Aires"), c("Maggie", "R-Ladies \n Gainesville"), c("Maggie", "R-Ladies Mid-Mo"), c("Maggie", "Greater Boston \n useR Group"), c("Maggie", "R-Ladies \n Riverside"), c("Maggie", "R-Ladies \n Santa Barbara"), c("Maggie", "R-Ladies Philly"), c("Maggie", "R-Ladies \n Washington D.C."), c("Maggie", "Salt Lake City \n R Users Group"), c("Maggie", "R-Ladies \n Cape Town"), c("Maggie", "R-Ladies Global"), c("R-Ladies \n Montevideo", "GURU::mvd"), c("R-Ladies \n Buenos Aires", "R en \n Buenos Aires"), c("R-Ladies Global", "R-Ladies \n Montevideo"), c("R-Ladies Global", "R-Ladies \n Buenos Aires"), c("R-Ladies Global", "R-Ladies \n Gainesville"), c("R-Ladies Global", "R-Ladies Mid-Mo"), c("R-Ladies Global", "R-Ladies \n Riverside"), c("R-Ladies Global", "R-Ladies \n Santa Barbara"), c("R-Ladies Global", "R-Ladies Philly"), c("R-Ladies Global", "R-Ladies \n Washington D.C."), c("R-Ladies Global", "R-Ladies \n Cape Town"))

arco <- arcplot(lab,
                col.nodes="mediumorchid4", # color de los nodos
                col.arcs = "plum", # color de los arcos
                lwd.arcs = 1.5, # grosor de los arcos
                col.labels = "lavenderblush4", # color texto ejes
                cex.labels = 0.8, # tamaño texto ejes
                las = 2) # posición texto ejes perpendicular
                
title(main = "Comunidades de R-Ladies y usuarios de R en las que participo",
      font.main = 2, col.main = "thistle4", 
      adj = 0, # ubicación a la izquierda
      sub = "@G33kyCats", col = "thistle",
      cex.sub = 0.75, font.sub = 3, col.sub = "thistle")


```
 
## _Desafío Día 6: gráficos de dona_

Para este desafío me basé en los ejemplos de [Datanovia](https://www.datanovia.com/en/blog/how-to-create-a-pie-chart-in-r-using-ggplot2/) utilizando los datos del 
Titanic {datasets} y en el paquete [ggpubr](https://cran.r-project.org/web/packages/ggpubr/index.html) creado por [Alboukadel Kassambara](https://rdrr.io/cran/ggpubr/man/ggdonutchart.html).

Realicé las 2 versiones de la misma dataset, en primer lugar utilizando ggplot() + coord_polar () y luego con ggdonutchart().

```{r gráfico de dona}
library(tidyverse)
```

```{r}
# Crear los datos de los pasajeros y tripulación
titanic <- data.frame(clase = c("Primera", "Seguda", "Tercera", "Tripulación"),
                      n = c(325, 285, 706, 885),
                      prop = c(14.8, 12.9, 32.1, 40.2))
titanic
```

```{r}
titanic <- titanic %>%
  arrange(desc(clase)) %>%
  mutate(lab.ypos = cumsum(prop) - 0.5 * prop)

palette <- c("#72ecee", "#45a4b8", "#06547a", "#3e8b7e")

ggplot(titanic, aes(x = 2, y = prop, fill = clase)) +
  geom_bar(stat = "identity", color = "white") +
  coord_polar(theta = "y", start = 0) +
  geom_text(aes(y = lab.ypos, label = prop), color = "white", fontface = "bold")+
  scale_fill_manual(values = palette) +
  theme_void() +
  xlim(0.5, 2.5) + # genera el efecto dona
  labs(title = "Pasajeros y tripulantes del Titanic",
       caption = "@G33kyCats") +
  theme(plot.title = element_text(face = "bold", hjust = 0.5, size = 18),
        plot.caption = element_text(face = "italic", size = 11))

```

```{r}
# Cargar ggpubr para hacer gráficos de donas
# install.packages("ggpubr")
# library(ggpubr)

 # ggdonutchart(titanic, "prop", 
 #              fill = "clase", color = "white",
 #              palette = c("#72ecee", "#45a4b8", "#06547a", "#3e8b7e"),
 #              lab.pos = "in", lab.font = "white")

```


## _Desafío Día 7: Gráficos ridgeline_

Para este desafío uní en una misma base de datos, la información de las temperaturas promedio de la estación metereológica de Punta del Este - Maldonado entre los años 1992-2012 proporcionada por [Climate-data](https://es.climate-data.org/america-del-sur/uruguay/maldonado/maldonado-3742/#climate-table). Seguí el ejemplo de gráfico ridgeline de [Datanovia](https://www.datanovia.com/en/blog/elegant-visualization-of-density-distribution-in-r-using-ridgeline/).

```{r gráficos ridgeline}
library(tidyverse)
library(readxl)
library(ggridges)
library(viridisLite)
library(viridis)
library(extrafontdb)
library(hrbrthemes)
```

```{r}
# Importar la base de datos
pde <- read_excel("C:/Users/Maggie/OneDrive/aR/datos_de_miercoles/data/temperatura_pde.xlsx")

pde$Mes <- factor(pde$Mes,levels = c("enero", "febrero", "marzo", "abril", "mayo", "junio", "julio", "agosto", "setiembre", "octubre", "noviembre", "diciembre"),
                   labels = c("enero", "febrero", "marzo", "abril", "mayo", "junio", "julio", "agosto", "setiembre", "octubre", "noviembre", "diciembre"))

ggplot(pde, aes(x = `Temperatura max (°C)`, y = `Mes`, fill = ..x..)) +
  geom_density_ridges_gradient(scale = 3, rel_min_height = 0.01) +
  scale_fill_viridis(name = "Temp. [F]", option = "C") +
  labs(title = "Temperaturas promedio en Punta del Este 1992-2012",
       caption = "@G33kyCats") +
  theme_ridges() +
    theme(
      legend.position="none",
      panel.spacing = unit(0.1, "lines"),
      strip.text.x = element_text(size = 8),
      plot.title = element_text(face = "bold", hjust = 0.5, size = 18),
      plot.caption = element_text(face = "italic", size = 11))
```

## _Desafío Día 8: Gráfico de contorno_

Para este desafío uní en una misma base de datos, la información de las temperaturas promedio de la estación metereológica de Punta del Este - Maldonado entre los años 1992-2012 proporcionada por [Climate-data](https://es.climate-data.org/america-del-sur/uruguay/maldonado/maldonado-3742/#climate-table). Seguí el ejemplo de Elio Campitelli (@d_olivaw) presentado en el Meetup de @renbaires.

```{r gráficos ridgeline}
library(tidyverse)
library(readxl)
```

```{r}
# Importar la base de datos
pde <- read_excel("C:/Users/Maggie/OneDrive/aR/datos_de_miercoles/data/temperatura_pde.xlsx")

pde$Mes <- factor(pde$Mes,levels = c("enero", "febrero", "marzo", "abril", "mayo", "junio", "julio", "agosto", "setiembre", "octubre", "noviembre", "diciembre"),
                   labels = c("ene", "feb", "mar", "abr", "may", "jun", "jul", "ago", "set", "oct", "nov", "dic"))
```

```{r}
ggplot(pde, aes(x = `Mes`, y = `Temperatura max (°C)`, group = 1)) +
  geom_density2d() +
  labs(title = "Temperaturas promedio en Punta del Este 1992-2012",
       caption = "@G33kyCats") +
  theme_light() +
  theme(plot.title = element_text(face = "bold", hjust = 0.5, size = 17),
        plot.caption = element_text(face = "italic", size = 10),
        axis.title.x = element_text(color = "gray40", size = 12, face = "bold"),
        axis.title.y = element_text(color = "gray40", size = 12, face = "bold"))
```

## _Desafío Día 09: Gráfico de áreas apiladas_

Para este desafío utilicé datos de [Gapminder](https://www.gapminder.org/data/), por medio del paquete creado por Jennifer Bryan.

Para cada uno de los 142 países, El paquete proporciona información sobre la expectativa de vida, el PIB per cápita y la población, generados cada cinco años, de 1952 a 2007.


Realicé el gráfico de áreas apiladas sobre la evolución del GdP per cápita de los Estados Partes del Mercosur.

```{r gráfico de áreas apiladas}
# Cargar los paquetes requeridos
library(tidyverse)
library(viridis)
library(gapminder)
```

```{r}
mercosur <- gapminder %>% 
  filter(country == "Argentina" | country == "Brazil" | country == "Paraguay" | country == "Uruguay") 

mercosur$country <- factor(mercosur$country,levels = c("Argentina", "Brazil", "Paraguay", "Uruguay"),
                   labels = c("Argentina", "Brasil", "Paraguay", "Uruguay")) 
  
ggplot(data = mercosur, aes(x = year, y = gdpPercap, fill = country)) +
  geom_area(alpha=0.6, size=.5, colour="white") +
  theme_minimal() +
  scale_fill_viridis(discrete = T) +
  labs(x = NULL, 
       y = NULL, 
       fill = NULL, 
       title = "Evolución del GdP per cápita en los Estados Partes del Mercosur",
       caption = "@G33kyCats") 


```


## _Desafío Día 10: Explorar paletas de colores_

Para este desafío utilicé la base de datos de la WNBA proporcionada para la carrera de Analista de Datos en R de [Dataquest](https://www.dataquest.io/path/data-analyst-r/). Para más información sobre la WNBA [visitar](https://www.wnba.com/stats/player-stats/).

Realicé un gráfico de barras que compara las frecuencias de las jugadoras en las distintas posiciones. 

```{r gráficos paleta de colores}
library(tidyverse)
library(viridis)
library(viridisLite)
library(readxl)
library(grid)
library(gridExtra)
library(ggthemes)
```

```{r}
# Importar la base de datos
wnba <- read.csv("C:/Users/Maggie/OneDrive/aR/datos_de_miercoles/data/wnba.csv")
```

```{r}
plot <- ggplot(wnba, aes(x = MIN, y = PTS)) +
  geom_point(aes(color = Pos, alpha = 0.8, size = 0.3)) +
  theme_few() +
  theme(legend.position = "none",
        axis.title.x = element_blank(),
        axis.title.y = element_blank(),
        axis.ticks = element_blank(),
        axis.text.x = element_blank(),
        axis.text.y = element_blank(),
        plot.title = element_text(face = "bold.italic", hjust = 0.5))

plot
```

```{r}
magma <- plot + 
  scale_color_viridis(option = "A", discrete = TRUE) + 
  ggtitle("magma")

magma
```
  
```{r}
inferno <- plot + 
  scale_color_viridis(option = "B", discrete = TRUE) + 
  ggtitle("inferno")

inferno
```

```{r}
plasma <- plot + 
  scale_color_viridis(option = "C", discrete = TRUE) + 
  ggtitle("plasma")

plasma
```

```{r}
viridis <- plot + 
  scale_color_viridis(option = "D", discrete = TRUE) + 
  ggtitle("viridis")

viridis
```

```{r}
viridis_grid <- grid.arrange(magma, inferno, plasma, viridis, ncol = 2,
                             top = textGrob("Explorando la paleta Viridis",
                                            y = 0.7,
                                            gp = gpar(fontsize = 15, fontface = "bold", fontfamily = "sans")),
                             bottom = textGrob("@G33kyCats",
                                               x = 0.9, # 0 es a la izquierda
                                               y = 0.5,
                                               gp = gpar(fontsize = 11, fontface = "italic", fontfamily = "sans", col = "thistle4"))) 

```


## _Desafío Día 11: Mapas de calor (heatmaps)_

Para este desafío utilicé la base de [Gapminder](https://www.gapminder.org/data/), por medio del paquete creado por Jennifer Bryan.

Repliqué el proceso que usé en el desafío del día 10, explorando la paleta de colores de Viridis, pero esta vez graficando un mapa de calor de la expectativa de vida por año en los países americanos. No obstante, eliminé los valores de los ejes para priorizar la visualización del mapa de calor. 

```{r heatmaps}
# Cargar los paquetes requeridos
library(tidyverse)
library(gapminder)
library(viridis)
library(viridisLite)
library(grid)
library(gridExtra)
library(ggthemes)
```

```{r}
# Importar la base de datos
americas <- gapminder %>%
  filter(continent == "Americas")

```

```{r}
tiles <- ggplot(data = americas, aes(x = country, y = year)) +  
  geom_tile(aes(fill = lifeExp)) +
  coord_flip() +
  theme_minimal() +
  theme(axis.title.x = element_blank(),
        axis.title.y = element_blank(),
        axis.ticks = element_blank(),
        axis.text.y = element_blank(),
        plot.title = element_text(face = "bold.italic", hjust = 0.5))

tiles

```

```{r}
magma_tiles <- tiles + 
  scale_fill_viridis(option = "A") + 
  ggtitle("magma")

magma_tiles
```
        
```{r}
inferno_tiles <- tiles + 
  scale_fill_viridis(option = "B") + 
  ggtitle("inferno")

inferno_tiles

```
        
```{r}
plasma_tiles <- tiles + 
  scale_fill_viridis(option = "C") + 
  ggtitle("plasma")

plasma_tiles
```

```{r}
viridis_tiles <- tiles + 
  scale_fill_viridis(option = "D") + 
  ggtitle("viridis")

viridis_tiles
```

```{r}
viridis_grid_tiles <- grid.arrange(magma_tiles, inferno_tiles, plasma_tiles, viridis_tiles, ncol = 2,
                                   top = textGrob("Explorando la paleta Viridis como mapa de calor",
                                                  y = 0.7,
                                                  gp = gpar(fontsize = 15, fontface = "bold", fontfamily = "sans")),
                                   bottom = textGrob("@G33kyCats",
                                                     x = 0.9, # 0 es a la izquierda
                                                     y = 0.5,
                                                     gp = gpar(fontsize = 11, fontface = "italic", fontfamily = "sans", col = "thistle4"))) 
```


## _Desafío Día 12: Gráfico de paleta (lollipop)_

Para este desafío me basé en los datos de la [FIBA](https://www.fibalivestats.com/u/FUBB/1219087/) para la última final de la Liga Uruguaya de Basquetbol 2018-2019, entre Malvín y Aguada. 

Realicé el gráfico de paleta con los puntos encestados por cada jugador, discriminados por equipo. 

```{r lollipop}
# Cargar los paquetes requeridos
library(tidyverse)
library(readxl)
```

```{r}
# Importar la base de datos
FIBA <- read_excel("C:/Users/Maggie/OneDrive/aR/datos_de_miercoles/data/FIBA.xlsx")

```

```{r}
lollipop <- ggplot(data = FIBA) +  
  geom_linerange(aes(x = Nombre, ymin = 0, ymax = Pts, colour = Equipo),
                 position = position_dodge(width = 1)) +
  geom_point(aes(x = Nombre, y = Pts, color = Equipo), size = 3,
             position = position_dodge(width = 1)) +
  coord_flip() +
  scale_colour_manual(values = c("forestgreen", "navyblue")) +
  theme_minimal() +
  labs(title = "Puntos por jugador partido final Liga 2018-2019",
       caption = "@G33kyCats") +
  theme(plot.title = element_text(face = "bold", hjust = 0.5, size = 17),
        plot.caption = element_text(color = "gray40", face = "italic", size = 10),
        axis.title.x = element_text(color = "gray40", size = 12, face = "bold"),
        axis.title.y = element_text(color = "gray40", size = 12, face = "bold"), 
        axis.text.x = element_text(color = "gray40", size = 8))

lollipop

```


## _Desafío Día 13: Visualización de datos temporales_

Para este desafío uní en una misma base de datos, la información de las temperaturas promedio de la estación metereológica de Punta del Este - Maldonado entre los años 1992-2012 proporcionada por [Climate-data](https://es.climate-data.org/america-del-sur/uruguay/maldonado/maldonado-3742/#climate-table).

```{r gráficos ridgeline}
library(tidyverse)
library(readxl)
library(RColorBrewer)
```

```{r}
# Importar la base de datos
pde <- read_excel("C:/Users/Maggie/OneDrive/aR/datos_de_miercoles/data/temperatura_pde.xlsx")

pde_long <- pde %>% 
  pivot_longer(cols = c(`Temperatura (°C)`, `Temperatura max (°C)`, `Temperatura min (°C)`),
               names_to = "Medición",
               values_to = "Temperatura")
```

```{r}
temporal <- ggplot(pde_long, aes(x = Fecha, y = Temperatura, group = `Medición`)) +
  geom_line(aes(col = `Medición`), size = 1) +
  labs(title = "Temperaturas promedio en Punta del Este 1992-2012",
       caption = "@G33kyCats") +
  scale_colour_brewer(palette="Set2") +
  theme_light() +
  theme(plot.title = element_text(face = "bold", hjust = 0.1, size = 17),
        plot.caption = element_text(color="gray40", face = "italic", size = 10),
        axis.title.x = element_text(color="gray40", size = 12, face="bold"),
        axis.title.y = element_text(color="gray40", size = 12, face="bold"))

temporal
```


## _Desafío Día 14: Gráficos de rectángulos/árbol (treemap)_

Para este desafío utilicé datos de [Gapminder](https://www.gapminder.org/data/), por medio del paquete creado por Jennifer Bryan.

Para cada uno de los 142 países, El paquete proporciona información sobre la expectativa de vida, el PIB per cápita y la población, generados cada cinco años, de 1952 a 2007.

Para hacer el gráfico de árbol, utilicé el paquete treemapify de David Wilkins, y me basé en su [ejemplo](https://cran.r-project.org/web/packages/treemapify/vignettes/introduction-to-treemapify.html) para realizar el mío.


```{r gráfico de árbol}
library(tidyverse)
library(ggplotify)
library(treemapify)
library(gapminder)
library(viridisLite)
library(viridis)
```

```{r}
data <- gapminder %>% 
  filter(year=="2007") %>% 
  select(-year) %>% 
  arrange(desc(pop)) %>%
  mutate(country = factor(country, country), 
         Continente = continent) 
  
 data$Continente <- factor(data$Continente,levels = c("Africa", "Americas", "Asia", "Europe", "Oceania"),
                    labels = c("África", "Américas", "Asia ", "Europa", "Oceanía"))
```

```{r}
treemap_coordenadas <- treemapify(data = data,
                      area = "pop",
                      fill = "lifeExp",
                      label = "country",
                      group = "Continente")

treemap_coordenadas
```

```{r}
treemap_plot <- ggplot(data, aes(area = pop, fill = lifeExp, label = country, subgroup = Continente)) +
  geom_treemap() +
  geom_treemap_subgroup_border() +
  geom_treemap_subgroup_text(place = "centre", grow = T, alpha = 0.5, colour =
                             "black", fontface = "italic", min.size = 0) +
  geom_treemap_text(colour = "white", place = "topleft", reflow = T) +
  scale_fill_viridis(option = "C", direction = -1) +
  # facet_wrap(~continent)
  labs(title = "Expectativa de vida y cantidad de habitantes por país",
       caption = "@G33kyCats",
       fill = "Años") +
  theme(plot.title = element_text(face = "bold", hjust = 0.5, size = 15),
        plot.caption = element_text(color="gray40", face = "italic", size = 10))

treemap_plot
```




## _Desafío Día 16: Gráfico de waffle_

Para este desafío, usé los datos del ranking con los 20 Lenguajes de Programación más usados según  [TIOBE](https://blog.nubecolectiva.com/los-20-lenguajes-de-programacion-mas-populares-abril-2020/). Fue un desafío en sí poder pasar los valores a la función waffle(), ya que no funcionaba pasándole directamente el data.frame. Por suerte, pude ver cómo lo resolvío [@grupodabia](https://github.com/DabiaCenter/30-dias-graficos/blob/master/dia_16/dia-16_grafica_waffle.R) y emular el proceso.

```{r gráfico de waffle}
library(ggplot2)
library(waffle)
library(dplyr)
```

```{r}

leng <- data.frame(
  "lenguajes" = c("Java", "C", "Python", "C++", "C#", "Visual Basic", "JavaScript", "PHP", "SQL", "R"),
  "porcentaje" = c(17, 17, 9, 7, 5, 5, 2, 2, 2, 2))

leng <- leng %>% 
  arrange(desc(porcentaje))

lenguajes_fav <- leng$porcentaje
names(lenguajes_fav) <- leng$lenguajes

waffle_leng <- waffle(lenguajes_fav, rows = 7, 
       title = "Lenguajes de programación más utilizados", 
       color = c("#f8b195", "#f67280", "#c06c84", "#6c5b7b", "#355c7d", "#114b5f", "#028174", "#45ada8", "#9de0ad", "#e5fcc2"),
       xlab = "@G33kyCats")

waffle_leng

```





## _Desafío Día 18: Visualización de datos espaciales_

Para este desafío utilicé los datos de geoservicios del Biovalor categoria I para Uruguay, proporcionados por el Ministerio de Vivienda Ordenamiento Territorial y Medio Ambiente - [MVOTMA](https://www.dinama.gub.uy/geoservicios/).

Y me basé en los ejemplos publicados por Francisco Urdinez y Andrés Cruz Labrín en [AnalizaR Datos Políticos](https://arcruz0.github.io/libroadp/index.html) y en el de Diana Alonso Aransay en [MappingGIS](https://mappinggis.com/2019/07/creacion-de-mapas-con-r-y-ggplot2/)

```{r datos espaciales}
library(dplyr)
library(ggplot2)
library(sf)
library(viridisLite)
library(viridis)
```

```{r}
shp_uycat <-  st_read("C:/Users/Maggie/OneDrive/aR/datos_de_miercoles/data/uy/paisseccat/PaisSecCat.shp")
shp_cat1 <- st_read("C:/Users/Maggie/OneDrive/aR/datos_de_miercoles/data/uy/biovalor_cat1/c416Polygon.shp")

```

Al consultar por la clase de los archivos “shp_uycat" y "shp_cat1” se puede observar que son tanto archivos de tipo “sf” como “data.frame”.

```{r}
class(shp_uycat)
class(shp_cat1)
```

```{r}
st_geometry(uycat)
st_geometry(shp_cat1)
```

```{r}
ggplot(data = shp_uycat) +
  geom_sf(aes(fill = DEPTO)) +
  scale_fill_viridis(name = "DEPTO", option = "D", discrete = TRUE) +
  xlab("Longitud") + ylab("Latitud") +
  labs(title = "Uruguay",
       caption = "@G33kyCats") +
  theme_light() +
  theme(plot.title = element_text(face = "bold", hjust = 0.5, size = 17),
        plot.caption = element_text(color = "gray40", face = "italic", size = 10),
        axis.title.x = element_text(color = "gray40", size = 12, face = "bold"),
        axis.title.y = element_text(color = "gray40", size = 12, face = "bold")) 
```

```{r}
biovalor1 <- ggplot(data = shp_cat1) +
  geom_sf(aes(fill = sp_2010)) +
  scale_fill_viridis(name = "Categoría I", option = "D") +
  xlab("Longitud") + ylab("Latitud") +
  labs(title = "Biovalor - Uruguay",
       caption = "@G33kyCats") +
  theme_light() +
  theme(plot.title = element_text(face = "bold", hjust = 0.5, size = 17),
        plot.caption = element_text(color = "gray40", face = "italic", size = 10),
        axis.title.x = element_text(color = "gray40", size = 12, face = "bold"),
        axis.title.y = element_text(color = "gray40", size = 12, face = "bold")) 

biovalor1
```



## _Desafío Día 19: Gráficos de flujo (stream graph)_

Para este desafío utilicé los datos del catálogo abierto de la Oficina de Presupuesto y Planeamiento - [OPP](https://catalogodatos.gub.uy/dataset/opp-ingresos-y-egresos-de-los-gobiernos-departamentales-y-egresos-de-los-gobiernos-municipales) sobre sistematiza de los ingresos de los Gobiernos Departamentales desde 1989 y de los egresos de los Gobiernos Municipales desde 2016, a partir de las Rendiciones de cuentas enviadas al Tribunal de Cuentas. Restringí los datos a los últimos 10 años (entre 1999 y 2009), para que fueran los más recientes.

Usé el paquete [streamgraph](https://github.com/hrbrmstr/streamgraph) y seguí el ejemplo de [r-graph-gallery](https://www.r-graph-gallery.com/154-basic-interactive-streamgraph-2.html) para hacerlo.

```{r  gráfico de flujo}
library(dplyr)
library(streamgraph)
library(ggplot2)
```

```{r}
ingresos <- read.csv("C:/Users/Maggie/OneDrive/aR/datos_de_miercoles/data/uy/ingresos_hist_2018.csv")

ingresos <- ingresos %>%
  filter(`AÑO` > 1998) %>%
  group_by(DEPARTAMENTO, `AÑO`) %>%
  summarize(promedio = mean(round(RECAUDADO)),
            suma = round(sum(RECAUDADO/1000000)))

```

```{r}
stream <- streamgraph(data = ingresos, key = "DEPARTAMENTO", value = "suma", date = "AÑO") %>%
  sg_fill_brewer("YlGnBu") %>% 
  sg_legend(show = TRUE, label = "Departamento") %>% 
  sg_title(title = "Ingresos (por millón) de los Gobiernos Departamentales entre 2000-2009")
# labs(title = "Biovalor - Uruguay",
#        caption = "@G33kyCats")

stream
```


## _Desafío Día 21: Gráfico con anotaciones_

Para este desafío utilicé la base de datos de animé [Kaggle](https://www.kaggle.com/canggih/anime-data-score-staff-synopsis-and-genre), la cual consta de 1563 observaciones.

Utilicé el paquete [gghighlight](https://www.rdocumentation.org/packages/gghighlight/versions/0.1.0) de Hiroaki Yutani, para resaltar en primer lugar mi animé favorito: Naruto (y su secuela Naruto Shippuuden). Y en segundo lugar, los animés que fueron identificados como favoritos por más de 40000 votos. 


```{r gráfico con anotaciones}
# Cargar los paquetes requeridos
library(dplyr)
library(ggplot2)
library(gghighlight)
```


```{r}
# Importar la base de datos
anime <- read.csv("C:/Users/Maggie/OneDrive/aR/datos_de_miercoles/data/dataanime.csv")

anime <- anime %>% 
  filter(Status == "Finished Airing", 
         Type == "TV") %>% 
  mutate(Naruto = if_else(Title == "Naruto" | Title == "Naruto: Shippuuden", 1, 0))
                         
```

```{r}
naruto <- ggplot(data = anime, aes(x = Favorites, y = Score, color = Title)) +
  geom_point() + 
  theme_minimal() +
  geom_point(data = filter(anime, Title == "Naruto"), color = "orange", size = 3) +
  geom_point(data = filter(anime, Title == "Naruto: Shippuuden"), color = "orange", size = 3) +
  gghighlight(Naruto == 1) + 
  scale_colour_manual(values = c("orange", "orange")) + 
  labs(title = "Mis animés favoritos",
       caption = "@G33kyCats",
       x = "Cantidad de favoritos",
       y = "Puntuación") +
  theme(legend.position = "none",
        plot.title = element_text(face = "bold", hjust = 0.5, size = 18),
        plot.caption = element_text(color = "gray40", face = "italic", size = 11),
        axis.title.x = element_text(color = "gray40", size = 12, face = "bold"),
        axis.title.y = element_text(color = "gray40", size = 12, face = "bold")) 
  
naruto    

```

```{r}

favs <- ggplot(data = anime, aes(x = Favorites, y = Score, color = Title)) +
  geom_point() + 
  theme_minimal() +
  gghighlight(Favorites > 40000 ) + 
  # scale_colour_manual(values = c("orange", "orange")) + 
  labs(title = "Animés con más 40.000 favoritos",
       caption = "@G33kyCats",
       x = "Cantidad de favoritos",
       y = "Puntuación") +
  theme(legend.position = "none",
        plot.title = element_text(face = "bold", hjust = 0.5, size = 18),
        plot.caption = element_text(color = "gray40", face = "italic", size = 11),
        axis.title.x = element_text(color = "gray40", size = 12, face = "bold"),
        axis.title.y = element_text(color = "gray40", size = 12, face = "bold")) 
  
favs    
```


## _Desafío Día 22: Visualización de datos textuales_

Para este desafío, me basé en la visualización de @bynans1 de R-Ladies Buenos Aires y le di un toque personal con el paquete word cloud de [Ian Fellows](http://blog.fellstat.com/?cat=11). 

Utilicé las letras de algunas canciones de La Trampa (*Caída libre, El Poeta dice la verdad, De nosotros dos, Las Décimas*) para hacer la visualización de los datos textuales.

```{r datos textuales}
library(tidyverse)
library(tidytext)
library(readxl)
library(wordcloud)
library(RColorBrewer)
```

```{r}
la_trampa <- read_excel("C:/Users/Maggie/OneDrive/aR/datos_de_miercoles/data/la_trampa.xlsx")
```

```{r}
cancion_palabras <- la_trampa %>% 
  select(text) %>%  
  unnest_tokens(word,text)
```

```{r}
cancion_palabras %>% 
  count(word, sort = TRUE)
```
Generé mi propia base de datos de stopwords para filtrar las palabras frecuentes no deseadas:
```{r}
stopwords <- read_excel("C:/Users/Maggie/OneDrive/aR/datos_de_miercoles/data/stopwords.xlsx")

```

```{r}
cancion_filtrada <- cancion_palabras %>%
  anti_join(stopwords, by = c("word" = "stopwords"))
```

```{r}
palabras_frecuencias <- cancion_filtrada %>% 
  count(word, sort = TRUE)

palabras_frecuencias
```

```{r}
wordcloud(palabras_frecuencias$word, 
          freq =  palabras_frecuencias$n,
          min.freq = 2,
          max.words = 49, 
          colors = brewer.pal(5,"Set2"), 
          random.order = FALSE, 
          random.color = TRUE,
          rot.per=.1,
          fixed.asp=TRUE,
          use.r.layout = FALSE)
title("La Trampa", sub = "@G33kyCats",
      cex.main = 2,   font.main= 4, 
      cex.sub = 0.75, font.sub = 3, col.sub = "gray40")
```





## _Desafío Día 24: Coropletas_

Para este desafío, actualicé la corolopleta que había utilizado para el projecto de la semana 14 de 2020 de [Tidy Tuesday](https://github.com/rfordatascience/tidytuesday/blob/master/data/2020/2020-03-31/readme.md) y me basé en el ejemplo paso a paso de [r-graph-gallery](https://www.r-graph-gallery.com/hexbin-map.html) para poder hacerlo.

Los datos corresponden a la producción anual de cerveza de Estados Unidos (fuente: Alcohol and Tobacco Tax and Trade Bureau - [TTB](https://www.ttb.gov/beer/statistics)).

Utilicé la producción de cerveza en botellas y latas del año 2019, con los valores mapeados por estado. Elegí representar los estados en formato hexagonal porque me parecía la forma más divertida para asociarlo con los Hex de R.   

```{r coropletas}
library(tidyverse)
library(geojsonio)
library(rgdal)
library(broom) #tidy spdf
library(rgeos) #permite calcular los centroides de cada hexágono para agregar la etiqueta
library(maps)
library(mapproj)
library(viridis)
library(viridisLite)
library(scales) #permite sobreescribir la notación científica de la escala por comas
```

```{r}
#Importar los datos
beer_states <- readr::read_csv('https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2020/2020-03-31/beer_states.csv')
```
Creando el hexágono  
```{r}
# Es necesario descargar los límites estatales hexagonales en formato geojson de: https://team.carto.com/u/andrew/tables/andrew.us_states_hexgrid/public/map

# Cargar los límites en como "Spatial Polygons Data Frame"
spdf <- geojson_read("C:/Users/Maggie/OneDrive/aR/TidyTuesday/DATA/us_states_hexgrid.geojson",  what = "sp")

# Reformatear los datos 
spdf@data = spdf@data %>%
  mutate(google_name = gsub(" \\(United States\\)", "", google_name))

# Fortificar en un formato de data frame format para que puedan ser mostrados con ggplot2
spdf_fortified <- tidy(spdf, region = "iso3166_2")

# Calcular los centroides de cada hexágono para agregar la etiqueta 
centros <- cbind.data.frame(data.frame(gCentroid(spdf, byid=TRUE), id=spdf@data$iso3166_2))

```
Agregando los nombres de los Estados
```{r}
# Unión de la información geoespacial y numérica
datos <- spdf_fortified %>%
  left_join(beer_states,  by=c("id" = "state")) %>%
  filter(year == "2019", type == "Bottles and Cans") 

```
Personalizando la coropleta hex

```{r}
coropleta <- ggplot() +
  geom_polygon(data = datos, aes(x = long, y = lat, fill =  barrels, group = group), size = 0, alpha = 0.95, color = "black") +
  geom_text(data = centros, aes(x = x, y = y, label = id), color = "brown", fontface = "bold")+
  labs(title = "Producción de cerveza por Estado", 
       subtitle = "Botellas y latas de 2019",
       caption = "@G33kyCats")+
  theme_void() +
  theme(plot.title = element_text(face = "bold", hjust = 0.5, size = 20),
        plot.subtitle = element_text(hjust = 0.5, size = 16),
        plot.caption = element_text(color = "gray40",face = "italic", size = 11))+
  scale_fill_viridis_c(name = "Barriles", begin = 0.53, end = 1, option = "inferno", direction = 1, trans = "log", na.value = NA, labels = comma) +
  coord_map()

coropleta
```


```{r}
